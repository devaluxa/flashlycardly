---
alwaysApply: true
---
# Data Handling Patterns

This project follows strict patterns for data retrieval, mutations, and validation to ensure type safety and security.

## Core Principles

1. **Data Retrieval**: ALWAYS use Server Components with query helper functions from `db/queries`
2. **Data Mutations**: ALWAYS use Server Actions that call mutation helper functions from `db/queries`
3. **Query Organization**: ALL database operations MUST be defined as helper functions in the `db/queries` directory
4. **Validation**: ALWAYS use Zod for data validation
5. **Type Safety**: Server Actions MUST receive validated, typed data (NEVER use FormData as the type)

## Required Dependencies

```typescript
import { z } from "zod";
```

## Database Query Helpers (`db/queries`)

ALL database operations MUST be defined as helper functions in the `db/queries` directory. This centralizes data access logic, improves reusability, and maintains consistent security patterns.

### Query Helper Structure

```typescript
// db/queries/decks.ts
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";

/**
 * Fetch all decks for a specific user
 */
export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

/**
 * Fetch a single deck by ID and userId (security check)
 */
export async function getDeckById(deckId: string, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck || null;
}

/**
 * Fetch all cards for a specific deck
 * Verifies deck ownership through join
 */
export async function getDeckCards(deckId: string, userId: string) {
  const result = await db.select({ card: cardsTable })
    .from(cardsTable)
    .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(cardsTable.deckId, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return result.map(r => r.card);
}

/**
 * Create a new deck
 */
export async function createDeckInDb(userId: string, title: string, description: string) {
  const [newDeck] = await db.insert(decksTable).values({
    userId,
    title,
    description,
  }).returning();
  
  return newDeck;
}

/**
 * Update a deck (with ownership verification)
 */
export async function updateDeckInDb(
  deckId: string, 
  userId: string, 
  data: { title?: string; description?: string }
) {
  const [updatedDeck] = await db.update(decksTable)
    .set({ 
      ...data,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return updatedDeck || null;
}

/**
 * Delete a deck (with ownership verification)
 */
export async function deleteDeckFromDb(deckId: string, userId: string) {
  const result = await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return result.length > 0;
}
```

## Data Retrieval (Server Components)

All data fetching MUST be done in Server Components using query helpers from `db/queries`.

### ✅ CORRECT - Server Component with Query Helper

```typescript
// app/decks/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/decks";

export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/");
  }
  
  // Fetch data using query helper
  const decks = await getUserDecks(userId);
  
  return (
    <div>
      {decks.map(deck => (
        <div key={deck.id}>{deck.title}</div>
      ))}
    </div>
  );
}
```

### ❌ WRONG - Direct Database Query in Server Component

```typescript
// app/decks/page.tsx
// ❌ DON'T DO THIS - Use query helpers instead
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq } from "drizzle-orm";

export default async function DecksPage() {
  const { userId } = await auth();
  
  // ❌ Direct db query - should use getUserDecks() helper
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return <div>...</div>;
}
```

### ❌ WRONG - Client Component with useEffect

```typescript
// DON'T DO THIS
"use client";

export default function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    fetch('/api/decks').then(/* ... */); // ❌ WRONG
  }, []);
}
```

### ❌ WRONG - API Route for Data Fetching

```typescript
// app/api/decks/route.ts
// ❌ DON'T create API routes just for data fetching
export async function GET() {
  // Use Server Components instead
}
```

## Data Mutations (Server Actions)

All database mutations (INSERT, UPDATE, DELETE) MUST be performed using Server Actions.

### Zod Schema Definition

Define Zod schemas for all data that will be passed to Server Actions:

```typescript
// lib/validations/deck.ts
import { z } from "zod";

export const createDeckSchema = z.object({
  title: z.string().min(1, "Title is required").max(100),
  description: z.string().max(500).optional(),
});

export const updateDeckSchema = z.object({
  id: z.string(),
  title: z.string().min(1, "Title is required").max(100),
  description: z.string().max(500).optional(),
});

export const deleteDeckSchema = z.object({
  id: z.string(),
});

// Export TypeScript types from Zod schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
export type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;
```

### Server Actions with Validation and Query Helpers

Server Actions MUST use query helper functions from `db/queries` instead of direct database calls.

```typescript
// app/actions/deck-actions.ts
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { 
  createDeckSchema, 
  updateDeckSchema, 
  deleteDeckSchema,
  type CreateDeckInput,
  type UpdateDeckInput,
  type DeleteDeckInput 
} from "@/lib/validations/deck";
import { 
  createDeckInDb, 
  updateDeckInDb, 
  deleteDeckFromDb 
} from "@/db/queries/decks";

export async function createDeck(input: CreateDeckInput) {
  // 1. Validate input with Zod
  const validatedData = createDeckSchema.parse(input);
  
  // 2. Authenticate user
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Call query helper to perform database operation
  const newDeck = await createDeckInDb(
    userId,
    validatedData.title,
    validatedData.description || ""
  );
  
  // 4. Revalidate relevant paths
  revalidatePath("/decks");
  
  return { success: true, deck: newDeck };
}

export async function updateDeck(input: UpdateDeckInput) {
  // 1. Validate input
  const validatedData = updateDeckSchema.parse(input);
  
  // 2. Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Call query helper to update (includes ownership verification)
  const updatedDeck = await updateDeckInDb(
    validatedData.id,
    userId,
    {
      title: validatedData.title,
      description: validatedData.description,
    }
  );
  
  if (!updatedDeck) {
    throw new Error("Deck not found or unauthorized");
  }
  
  // 4. Revalidate
  revalidatePath("/decks");
  revalidatePath(`/decks/${validatedData.id}`);
  
  return { success: true, deck: updatedDeck };
}

export async function deleteDeck(input: DeleteDeckInput) {
  // 1. Validate input
  const validatedData = deleteDeckSchema.parse(input);
  
  // 2. Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Call query helper to delete (includes ownership verification)
  const success = await deleteDeckFromDb(validatedData.id, userId);
  
  if (!success) {
    throw new Error("Deck not found or unauthorized");
  }
  
  // 4. Revalidate
  revalidatePath("/decks");
  
  return { success: true };
}
```

### Calling Server Actions from Client Components

```typescript
// components/create-deck-form.tsx
"use client";

import { useState } from "react";
import { createDeck } from "@/app/actions/deck-actions";
import type { CreateDeckInput } from "@/lib/validations/deck";

export function CreateDeckForm() {
  const [isLoading, setIsLoading] = useState(false);
  
  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setIsLoading(true);
    
    const formData = new FormData(e.currentTarget);
    
    // Create properly typed object
    const input: CreateDeckInput = {
      title: formData.get("title") as string,
      description: formData.get("description") as string,
    };
    
    try {
      await createDeck(input);
      // Handle success
    } catch (error) {
      // Handle validation or other errors
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="title" required />
      <textarea name="description" />
      <button type="submit" disabled={isLoading}>
        Create Deck
      </button>
    </form>
  );
}
```

## Validation Rules

### Always Use Zod for:

1. **Server Action inputs** - Validate all data before processing
2. **String length constraints** - Use `.min()`, `.max()`
3. **Required vs optional fields** - Use `.optional()` for optional fields
4. **Type coercion** - Use `.coerce.number()`, `.coerce.boolean()` when needed
5. **Custom validation** - Use `.refine()` for complex validation logic

### Common Zod Patterns

```typescript
import { z } from "zod";

// String validation
z.string().min(1, "Required").max(100, "Too long");

// Optional field
z.string().max(500).optional();

// Number validation
z.coerce.number().positive().int();

// Boolean
z.boolean();

// Enum
z.enum(["easy", "medium", "hard"]);

// Date
z.coerce.date();

// Array
z.array(z.string());

// Nested object
z.object({
  name: z.string(),
  metadata: z.object({
    tags: z.array(z.string()),
  }),
});

// Custom validation
z.string().refine((val) => val.length > 0, {
  message: "Cannot be empty",
});
```

## Error Handling

Server Actions should handle Zod validation errors gracefully:

```typescript
"use server";

import { ZodError } from "zod";

export async function myServerAction(input: MyInput) {
  try {
    const validatedData = mySchema.parse(input);
    // ... rest of logic
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof ZodError) {
      return { 
        success: false, 
        error: "Validation failed", 
        issues: error.issues 
      };
    }
    
    return { 
      success: false, 
      error: error instanceof Error ? error.message : "Unknown error" 
    };
  }
}
```

## Summary Checklist

Before implementing any feature:

- [ ] Data retrieval is in a Server Component
- [ ] Server Component uses query helpers from `db/queries` (NOT direct db calls)
- [ ] Database mutations use Server Actions (no API routes for mutations)
- [ ] Server Actions call mutation helpers from `db/queries` (NOT direct db calls)
- [ ] Query helper functions are defined in `db/queries` directory
- [ ] Query helpers include userId filtering for security
- [ ] Zod schema is defined for Server Action input
- [ ] TypeScript type is exported from Zod schema (using `z.infer<>`)
- [ ] Server Action parameter uses the TypeScript type (NOT FormData)
- [ ] Server Action validates input with `.parse()` or `.safeParse()`
- [ ] Authentication check is performed in Server Action
- [ ] `revalidatePath()` is called after mutations
- [ ] Error handling catches ZodError specifically

## What NOT to Do

```typescript
// ❌ NEVER use FormData as the parameter type
export async function myAction(formData: FormData) {
  // Use typed object instead!
}

// ❌ NEVER make direct database calls in Server Components
// app/decks/page.tsx
export default async function DecksPage() {
  const { userId } = await auth();
  const decks = await db.select().from(decksTable).where(eq(decksTable.userId, userId)); // ❌ WRONG
  // Use query helper instead: const decks = await getUserDecks(userId);
}

// ❌ NEVER make direct database calls in Server Actions
export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  await db.insert(decksTable).values({...}); // ❌ WRONG
  // Use query helper instead: await createDeckInDb(userId, title, description);
}

// ❌ NEVER skip Zod validation
export async function myAction(input: MyInput) {
  // Missing: const validatedData = mySchema.parse(input);
  await createDeckInDb(...); // Unsafe without validation!
}

// ❌ NEVER fetch data in Client Components
"use client";
export default function MyComponent() {
  useEffect(() => {
    fetch('/api/data'); // Use Server Component with query helpers instead!
  }, []);
}

// ❌ NEVER create API routes for simple CRUD
// app/api/decks/route.ts
export async function POST(request: Request) {
  // Use Server Action with query helpers instead!
}
```

## File Organization

```
src/
├── app/
│   ├── actions/           # Server Actions (call query helpers)
│   │   ├── deck-actions.ts
│   │   └── card-actions.ts
│   └── decks/
│       └── page.tsx       # Server Components (call query helpers)
├── components/            # Client Components
│   └── create-deck-form.tsx
├── db/
│   ├── index.ts          # Database instance
│   ├── schema.ts         # Database schema
│   └── queries/          # Query helper functions (ALL db operations go here)
│       ├── decks.ts      # Deck-related queries
│       └── cards.ts      # Card-related queries
└── lib/
    └── validations/       # Zod schemas
        ├── deck.ts
        └── card.ts
```

## Query Helper Naming Conventions

Follow these naming conventions for query helper functions:

- **Fetch operations**: `getUserDecks()`, `getDeckById()`, `getDeckCards()`
- **Create operations**: `createDeckInDb()`, `createCardInDb()`
- **Update operations**: `updateDeckInDb()`, `updateCardInDb()`
- **Delete operations**: `deleteDeckFromDb()`, `deleteCardFromDb()`

All query helpers MUST:
- Accept `userId` as a parameter for security filtering
- Return typed results (inferred from Drizzle schema)
- Include proper error handling
- Use descriptive JSDoc comments
